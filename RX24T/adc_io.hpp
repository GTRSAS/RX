#pragma once
//=====================================================================//
/*!	@file
	@brief	RX グループ A/D 制御 @n
			Copyright 2016 Kunihito Hiramatsu
	@author	平松邦仁 (hira@rvf-rc45.net)
*/
//=====================================================================//
#include "common/renesas.hpp"
#include "common/vect.h"

namespace device {

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	/*!
		@brief  A/D 制御クラス
		@param[in]	ADCU	A/D チャネル・ユニット
		@param[in]	TASK	割り込みタスク
	*/
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
	template <class ADCU, class TASK>
	class adc_io {
	public:

#if 0
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		/*!
			@brief  ＋基準電圧タイプ
		*/
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		enum class REFP : uint8_t {
			VDD,      ///< VDD
			VREFP,    ///< P20/VREFP
			INT_1_45  ///< 内臓 1.45V リファレンス
		};


		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		/*!
			@brief  －基準電圧タイプ
		*/
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
		enum class REFM : uint8_t {
			VSS,    ///< VSS
			VREFM,  ///< P21/VREFM
		};
#endif

	private:
		static TASK task_;

		uint8_t	level_;

//		static volatile uint16_t value_[NUM];

		static inline void sleep_() { asm("nop"); }

	public:
		//-----------------------------------------------------------------//
		/*!
			@brief	コンストラクター
		 */
		//-----------------------------------------------------------------//
		adc_io() : level_(0) {
//			for(uint8_t i = 0; i < NUM; ++i) value_[i] = 0;
		}


		//-----------------------------------------------------------------//
		/*!
			@brief	スタート
			@param[in]	refp	＋基準電圧選択
			@param[in]	refm	－基準電圧選択
			@param[in]	level	割り込みレベル（１～２）、０の場合はポーリング
		 */
		//-----------------------------------------------------------------//
//		void start(REFP refp, REFM refm, uint8_t level)
		void start(uint8_t level)
		{
			level_ = level;


		}


		//-----------------------------------------------------------------//
		/*!
			@brief	読み込み同期（ポーリングの場合は無視される）
		 */
		//-----------------------------------------------------------------//
		void sync() const {
			if(level_ == 0) return;
///			while(ADS() < NUM) sleep_();
		}


		//-----------------------------------------------------------------//
		/*!
			@brief	スキャン開始（割り込みモードの場合のみ有効）
			@param[in]	top	開始チャネル
		 */
		//-----------------------------------------------------------------//
		void start_scan(uint8_t top = 0)
		{

		}


		//-----------------------------------------------------------------//
		/*!
			@brief	A/D 変換結果を取得
			@param[in]	ch	変換チャネル
			@return 変換結果（上位１０ビットが有効な値）
		 */
		//-----------------------------------------------------------------//
		uint16_t get(typename ADCU::CH ch)
		{
			return 0;
		}
	};

//	template<uint16_t NUM, class TASK>
//		volatile uint16_t adc_io<NUM, TASK>::value_[NUM]; 
}
